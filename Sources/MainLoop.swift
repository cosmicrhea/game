import Assimp
import CJolt
import Foundation
import Jolt

private let startingScene = "nexus"
private let startingEntry = "8"

// private let startingScene = "chiefs_office"
// private let startingEntry = "1"
// private let startingScene = "shooting_range"
// private let startingEntry = "range"

@Editable final class MainLoop: RenderLoop {
  static var shared: MainLoop?

  // Scene configuration
  private(set) var sceneName: String = startingScene
  var currentAreaName: String?

  // Gameplay state
  private var smoothedFPS: Float = 60.0

  // Capsule mesh from GLB file
  private var capsuleMeshInstances: [MeshInstance] = []

  // Foreground meshes from scene (nodes with -fg suffix)
  private var foregroundMeshInstances: [MeshInstance] = []

  // Capsule height offset - adjust if capsule origin is at center instead of bottom
  @Editor(0.0...2.0) var capsuleHeightOffset: Float = 1.2

  // Systems
  private var physicsWorld: PhysicsWorld!
  private var cameraSystem: CameraSystem!
  private var playerController: PlayerController!
  private var interactionSystem: InteractionSystem!
  private var enemySystem: EnemySystem!
  private var weaponSystem: WeaponSystem!

  // Expose player position/rotation for rendering and debug
  var playerPosition: vec3 {
    return playerController.position
  }
  var playerRotation: Float {
    return playerController.rotation
  }

  var currentProjection: mat4 = mat4(1)  // Accessible by debug renderer implementation
  var currentView: mat4 = mat4(1)  // Accessible by debug renderer implementation

  @Editor var visualizePhysics: Bool = false
  @Editor var visualizeEntries: Bool = false
  @Editor var disableDepth: Bool = false
  private var showDebugText: Bool = true
  @Editor var showEnemyDebugOverlay: Bool = false

  @Editor func shakeScreen() { ScreenShake.shared.shake(.subtle) }
  @Editor func shakeScreenMore() { ScreenShake.shared.shake(.heavy) }
  @Editor func shakeScreenVertically() { ScreenShake.shared.shake(.subtle, axis: .vertical) }

  // Scene
  private(set) var scene: Scene?

  // Camera access (delegated to CameraSystem)
  private var camera: Assimp.Camera? {
    return cameraSystem.getCamera()
  }
  private var cameraWorldTransform: mat4 {
    return cameraSystem.cameraWorldTransform
  }

  // Scene lights
  private var sceneLights: [(light: Assimp.Light, worldTransform: mat4)] = []

  // Prerendered environment renderer
  private var prerenderedEnvironment: PrerenderedEnvironment?

  //@Editable
  var nearestNeighbor: Bool = true {
    didSet {
      prerenderedEnvironment?.nearestNeighborFiltering = nearestNeighbor
    }
  }

  // @Editable
  var selectedCamera: String {
    get { cameraSystem.selectedCamera }
    set { cameraSystem.selectedCamera = newValue }
  }

  // Main menu system
  private let mainMenu: MainMenu
  private var showingMainMenu: Bool = false

  // Pickup view system
  private var pickupView: PickupView?
  private var showingPickupView: Bool = false

  // Pause screen system
  private let pauseScreenStack: PauseScreenStack
  private var showingPauseScreen: Bool = false

  // Dialog system
  private(set) var dialogView: DialogView!
  // Scene script instance
  private var sceneScript: Script?

  // Room boundaries
  private let roomSize: Float = 10.0
  private var restrictMovementToRoom: Bool = false
  private let boxSize: Float = 2.0
  private let boxPosition: vec3 = vec3(3, 0, 3)

  init() {
    // Initialize dialog view
    dialogView = DialogView()

    // Initialize main menu
    mainMenu = MainMenu()

    // Initialize pause screen
    pauseScreenStack = PauseScreenStack()

    // Initialize systems (order matters - physicsWorld must be first)
    physicsWorld = PhysicsWorld(renderLoop: self)
    cameraSystem = CameraSystem()
    playerController = PlayerController(physicsWorld: physicsWorld)
    // InteractionSystem needs all three systems, so create it last
    interactionSystem = InteractionSystem(
      physicsWorld: physicsWorld,
      playerController: playerController,
      cameraSystem: cameraSystem
    )
    // EnemySystem needs physicsWorld and playerController
    enemySystem = EnemySystem(physicsWorld: physicsWorld, playerController: playerController)

    // Initialize weapon system (needs physicsWorld, enemySystem, cameraSystem, playerController)
    weaponSystem = WeaponSystem(
      inventory: Inventory.player1,
      slotGrid: mainMenu.inventoryView.slotGrid,
      physicsWorld: physicsWorld,
      enemySystem: enemySystem,
      cameraSystem: cameraSystem,
      playerController: playerController
    )

    // Register all scene scripts (auto-generated by build tool)
    // This registers factory functions - they'll be called lazily when scripts are created
    registerAllSceneScripts()

    // Load capsule mesh
    loadCapsuleMesh()

    // Set shared instance (after all properties are initialized)
    // Used by @SceneScript macro to access scene and dialogView
    MainLoop.shared = self

    // Load starting scene
    Task {
      await loadScene(startingScene, entry: startingEntry)
    }
  }

  /// Load scene lights and their world transforms
  private func loadSceneLights() {
    guard let scene = self.scene else { return }
    sceneLights.removeAll()

    for light in scene.lights {
      guard let lightName = light.name else { continue }

      // Find the node with the same name as the light
      if let lightNode = scene.rootNode.findNode(named: lightName) {
        let worldTransform = lightNode.assimpNode.calculateWorldTransform(scene: scene.assimpScene)
        sceneLights.append((light: light, worldTransform: worldTransform))
        logger.trace("üí° Loaded light '\(lightName)' type: \(light.type)")
      } else {
        logger.warning("‚ö†Ô∏è Light node '\(lightName)' not found in scene graph")
      }
    }

    if sceneLights.isEmpty {
      logger.warning("‚ö†Ô∏è No lights found in scene")
    }
  }

  /// Load foreground meshes from nodes with -fg suffix (recursively includes subnodes)
  private func loadForegroundMeshes(scene: Scene) {
    foregroundMeshInstances.removeAll()

    func traverse(_ node: Node) {
      // Check if this node has -fg suffix
      if let name = node.name, name.hasSuffix("-fg") {
        // Get all meshes from this node (create MeshInstance regardless of isHidden)
        // Visibility is checked at render time
        for i in 0..<node.numberOfMeshes {
          let meshIndex = node.meshes[i]
          if meshIndex < scene.meshes.count {
            let mesh = scene.meshes[Int(meshIndex)]

            // Only create instance if mesh has vertices
            guard mesh.numberOfVertices > 0 else { continue }

            // Get transform matrix for this mesh
            let transformMatrix = scene.getTransformMatrix(for: mesh)

            // Create MeshInstance (reusing existing init!)
            let meshInstance = MeshInstance(
              scene: scene,
              mesh: mesh,
              transformMatrix: transformMatrix,
              sceneIdentifier: scene.filePath
            )

            // Store node reference for checking visibility at render time
            meshInstance.node = node

            foregroundMeshInstances.append(meshInstance)
            logger.trace("‚úÖ Created foreground MeshInstance for node '\(name)' mesh \(i)")
          }
        }
      }

      // Recursively traverse children (even if this node doesn't have -fg, children might)
      for child in node.children {
        traverse(child)
      }
    }

    traverse(scene.rootNode)
    logger.trace("‚úÖ Loaded \(foregroundMeshInstances.count) foreground mesh instances")
  }

  /// Spawn enemies from Enemy_* nodes in the scene
  private func spawnEnemiesFromScene(scene: Scene) {
    var enemyCount = 0

    func traverse(_ node: Node) {
      // Check if this node is an enemy spawn point
      if let nodeName = node.name, nodeName.hasPrefix("Enemy_") {
        // Extract enemy type from name (e.g., "Enemy_Civilian", "Enemy_Dog.001")
        let enemyTypeName = String(nodeName.dropFirst("Enemy_".count))

        // Remove any numeric suffix (e.g., ".001", ".002") for type matching
        let baseTypeName: String
        if let dotIndex = enemyTypeName.firstIndex(of: ".") {
          baseTypeName = String(enemyTypeName[..<dotIndex])
        } else {
          baseTypeName = enemyTypeName
        }

        // Get world transform for position and rotation
        let worldTransform = node.assimpNode.calculateWorldTransform(scene: scene.assimpScene)
        let position = vec3(worldTransform[3].x, worldTransform[3].y, worldTransform[3].z)

        // Extract forward direction and calculate rotation (same as entry positioning)
        let fwd = vec3(worldTransform[2].x, worldTransform[2].y, worldTransform[2].z)
        let yaw = atan2(fwd.x, fwd.z)
        let rotation = yaw - (.pi * 0.5)

        // Adjust Y position to account for capsule half-height (enemies spawn at center)
        let capsuleHalfHeight: Float = 0.8
        let adjustedPosition = vec3(position.x, position.y + capsuleHalfHeight, position.z)

        // Spawn appropriate enemy type
        let enemyType: Enemy.Type
        switch baseTypeName.lowercased() {
        case "civilian":
          enemyType = CivilianEnemy.self
        case "dog":
          enemyType = DogEnemy.self
        default:
          logger.warning("‚ö†Ô∏è Unknown enemy type '\(baseTypeName)' at node '\(nodeName)'")
          return
        }

        if let _ = enemySystem.spawnEnemy(enemyType, at: adjustedPosition, rotation: rotation) {
          enemyCount += 1
          logger.trace("‚úÖ Spawned \(baseTypeName) enemy at \(position)")
        } else {
          logger.warning("‚ö†Ô∏è Failed to spawn \(baseTypeName) enemy at node '\(nodeName)'")
        }
      }

      // Recursively traverse children
      for child in node.children {
        traverse(child)
      }
    }

    traverse(scene.rootNode)

    if enemyCount > 0 {
      logger.debug("‚úÖ Spawned \(enemyCount) enemies from scene")
    }
  }

  /// Get lighting from scene lights (returns main light and fill light)
  private func getSceneLighting() -> (
    mainLight: (direction: vec3, color: vec3, intensity: Float),
    fillLight: (direction: vec3, color: vec3, intensity: Float)
  ) {
    // Default lighting
    var mainLight = (direction: vec3(0, -1, 0), color: vec3(1, 1, 1), intensity: Float(1.0))
    var fillLight = (direction: vec3(-0.3, -0.5, -0.2), color: vec3(0.8, 0.9, 1.0), intensity: Float(0.4))

    // Use first directional light as main light
    if let firstDirectionalLight = sceneLights.first(where: { $0.light.type == .directional }) {
      let light = firstDirectionalLight.light
      let worldTransform = firstDirectionalLight.worldTransform

      // Transform light direction to world space
      // Light direction is in local space, transform it using the rotation part of the world transform
      let localDir = vec3(light.direction.x, light.direction.y, light.direction.z)
      // Extract rotation matrix (first 3x3) and transform the direction
      let rotMatrix = mat3(
        vec3(worldTransform[0].x, worldTransform[0].y, worldTransform[0].z),
        vec3(worldTransform[1].x, worldTransform[1].y, worldTransform[1].z),
        vec3(worldTransform[2].x, worldTransform[2].y, worldTransform[2].z)
      )
      let worldDir = normalize(rotMatrix * localDir)

      // Use negative direction (light points toward negative direction)
      mainLight.direction = -worldDir
      mainLight.color = vec3(light.colorDiffuse.x, light.colorDiffuse.y, light.colorDiffuse.z)
      mainLight.intensity = 1.0

      logger.trace(
        "üí° Using directional light '\(light.name ?? "unnamed")' - direction: \(mainLight.direction), color: \(mainLight.color)"
      )
    }

    // Use second directional light or first point light as fill light if available
    if sceneLights.count > 1 {
      let secondLight = sceneLights[1]
      let light = secondLight.light
      let worldTransform = secondLight.worldTransform

      if light.type == .directional {
        let localDir = vec3(light.direction.x, light.direction.y, light.direction.z)
        let rotMatrix = mat3(
          vec3(worldTransform[0].x, worldTransform[0].y, worldTransform[0].z),
          vec3(worldTransform[1].x, worldTransform[1].y, worldTransform[1].z),
          vec3(worldTransform[2].x, worldTransform[2].y, worldTransform[2].z)
        )
        let worldDir = normalize(rotMatrix * localDir)
        fillLight.direction = -worldDir
      } else if light.type == .point {
        // For point lights, calculate direction from light position to player
        let lightPos = vec3(worldTransform[3].x, worldTransform[3].y, worldTransform[3].z)
        let toPlayer = normalize(playerPosition - lightPos)
        fillLight.direction = toPlayer
      }

      fillLight.color = vec3(light.colorDiffuse.x, light.colorDiffuse.y, light.colorDiffuse.z)
      fillLight.intensity = 0.4
    }

    return (mainLight, fillLight)
  }

  /// Syncs `camera`, its node/world transform and prerender near/far from the given camera name
  private func syncActiveCamera(name: String) {
    cameraSystem.syncActiveCamera(name: name)
  }

  private func loadCapsuleMesh() {
    Task {
      do {
        let loaded = try await MeshInstance.loadAsync(
          path: "Actors/capsule",
          onSceneProgress: { _ in },
          onTextureProgress: { _, _, _ in }
        )
        await MainActor.run {
          self.capsuleMeshInstances = loaded
        }
      } catch {
        logger.error("Failed to load capsule mesh: \(error)")
      }
    }
  }

  // MARK: Input

  func onKeyPressed(window: Window, key: Keyboard.Key, scancode: Int32, mods: Keyboard.Modifier) {
    guard Input.player1.isEnabled else { return }

    if showingPickupView {
      // Forward input to pickup view
      pickupView?.onKeyPressed(window: window, key: key, scancode: scancode, mods: mods)
      return
    }

    if showingPauseScreen {
      // Don't process input if we're fading out
      if pauseScreenStack.isFadingOut {
        return
      }
      // Handle escape key to close pause screen (only if at root)
      if key == .escape {
        // Check if NavigationStack is at root - if not, let it handle going back
        if pauseScreenStack.isAtRoot {
          UISound.cancel()
          hidePauseScreen()
          return
        }
      }
      // Forward input to pause screen (including escape if not at root)
      pauseScreenStack.onKeyPressed(window: window, key: key, scancode: scancode, mods: mods)
      return
    }

    if showingMainMenu {
      // Handle escape key with nested view support
      if key == .escape {
        // If there's a nested view (item/document), let MainMenu handle it first
        if mainMenu.hasNestedViewOpen {
          // Forward to main menu, which will forward to the nested view
          mainMenu.onKeyPressed(window: window, key: key, scancode: scancode, mods: mods)
          return
        }
        // No nested view, close the main menu
        UISound.cancel()
        hideMainMenu()
        return
      }

      // Handle I, M, and Tab to close main menu (check for nested views first)
      if key == .i || key == .m || key == .tab {
        // If there's a nested view (item/document), let MainMenu handle it first
        if mainMenu.hasNestedViewOpen {
          // Forward to main menu, which will forward to the nested view
          mainMenu.onKeyPressed(window: window, key: key, scancode: scancode, mods: mods)
          return
        }
        // No nested view, close the main menu
        UISound.cancel()
        hideMainMenu()
        return
      }

      // Forward other input to main menu
      mainMenu.onKeyPressed(window: window, key: key, scancode: scancode, mods: mods)
    } else {
      // Handle dialog advancement keys first (these always work)
      switch key {
      case .f, .enter, .numpadEnter:
        // Handle interaction - either advance dialog or interact with action
        // Dialog advancement keys always work, even when dialog is active
        if dialogView.isActive {
          // If dialog is showing, try to advance it
          if dialogView.tryAdvance() {
            // Advanced to next page/chunk
            //UISound.select()
          } else if dialogView.isFinished {
            // Dialog finished, dismiss it (disables input synchronously)
            dialogView.dismiss()
          }
        } else {
          // No dialog showing, handle interaction with detected action
          interactionSystem.handleInteraction(sceneScript: sceneScript)
        }
        return

      case .space:
        // Handle aim mode (Space) - toggle mode only
        if dialogView.isActive {
          // If dialog is showing, try to advance it
          if dialogView.tryAdvance() {
            // Advanced to next page/chunk
          } else if dialogView.isFinished {
            dialogView.dismiss()
          }
        } else {
          // Handle aim mode toggle
          if weaponSystem.usesToggledAiming {
            weaponSystem.toggleAim()
          } else {
            // Hold mode - enter ready aim on press
            weaponSystem.enterReadyAim()
          }
        }
        return

      default:
        break
      }

      // Skip other gameplay keys if dialog is active and not finished
      guard !dialogView.isActive else { return }

      // Handle other gameplay keys
      switch key {
      case .tab, .i:
        UISound.select()
        showMainMenu(tab: .inventory)

      case .m:
        UISound.select()
        showMainMenu(tab: .map)

      case .escape:
        // Exit debug camera override mode if active
        if cameraSystem.isDebugCameraOverrideMode {
          UISound.select()
          cameraSystem.setDebugCameraOverrideMode(false)
        } else {
          // Show pause screen if no other UI is showing and dialog is not active
          if !dialogView.isActive {
            UISound.select()
            showPauseScreen()
          }
        }
        break

      case .semicolon:
        UISound.select()
        // Enter debug camera override mode when manually cycling cameras
        cameraSystem.setDebugCameraOverrideMode(true)
        cameraSystem.cycleToNextCamera()

      case .apostrophe:
        UISound.select()
        // Enter debug camera override mode when manually cycling cameras
        cameraSystem.setDebugCameraOverrideMode(true)
        cameraSystem.cycleToPreviousCamera()

      case .graveAccent:
        UISound.select()
        // Enter debug camera override mode and switch to debug camera
        cameraSystem.setDebugCameraOverrideMode(true)
        cameraSystem.switchToDebugCamera()

      case .r:
        UISound.select()
        // Reset player to spawn
        playerController.resetToSpawn()

      case .l:
        UISound.select()
        // Toggle mist visualization
        if let env = prerenderedEnvironment {
          env.showMist.toggle()
          logger.trace("üå´Ô∏è Debug: Mist visualization = \(env.showMist ? "ON" : "OFF")")
        }

      case .u:
        UISound.select()
        visualizePhysics.toggle()
        logger.trace("Debug renderer: \(visualizePhysics ? "ON" : "OFF")")

      case .backspace:
        UISound.select()
        showDebugText.toggle()

      case .leftControl, .rightControl:
        // Fire weapon (Ctrl)
        guard weaponSystem.isAiming else { break }
        _ = weaponSystem.fire()
        break

      default:
        break
      }
    }
  }

  func onMouseMove(window: Window, x: Double, y: Double) {
    guard Input.player1.isEnabled else { return }

    if showingPickupView {
      pickupView?.onMouseMove(window: window, x: x, y: y)
    } else if showingPauseScreen {
      pauseScreenStack.onMouseMove(window: window, x: x, y: y)
    } else if showingMainMenu {
      mainMenu.onMouseMove(window: window, x: x, y: y)
    }
  }

  func onMouseButton(window: Window, button: Mouse.Button, state: ButtonState, mods: Keyboard.Modifier) {
    guard Input.player1.isEnabled else { return }

    if showingPickupView {
      pickupView?.onMouseButton(window: window, button: button, state: state, mods: mods)
    } else if showingPauseScreen {
      pauseScreenStack.onMouseButtonPressed(window: window, button: button, mods: mods)
    } else if showingMainMenu {
      mainMenu.onMouseButton(window: window, button: button, state: state, mods: mods)
    }
  }

  func onMouseButtonPressed(window: Window, button: Mouse.Button, mods: Keyboard.Modifier) {
    guard Input.player1.isEnabled else { return }

    if showingPickupView {
      pickupView?.onMouseButtonPressed(window: window, button: button, mods: mods)
      return
    }

    if showingPauseScreen {
      // Don't process input if we're fading out
      if pauseScreenStack.isFadingOut {
        return
      }
      pauseScreenStack.onMouseButtonPressed(window: window, button: button, mods: mods)
      return
    }

    if showingMainMenu {
      // Handle right-click with nested view support (same as Escape)
      if button == .right {
        // If there's a nested view (item/document), let MainMenu handle it first
        if mainMenu.hasNestedViewOpen {
          // Forward to main menu, which will forward to the nested view
          mainMenu.onMouseButtonPressed(window: window, button: button, mods: mods)
          return
        }
        // No nested view, close the main menu
        UISound.cancel()
        hideMainMenu()
        return
      }

      // Forward other mouse input to main menu
      mainMenu.onMouseButtonPressed(window: window, button: button, mods: mods)
    } else {
      // Handle interaction - either advance dialog or interact with action
      // Dialog advancement always works, even when dialog is active
      if button == .left {
        if dialogView.isActive {
          // If dialog is showing, try to advance it
          if dialogView.tryAdvance() {
            // Advanced to next page/chunk
            UISound.select()
          } else if dialogView.isFinished {
            // Dialog finished, dismiss it (disables input synchronously)
            dialogView.dismiss()
            UISound.select()
          }
          // } else {
          //   // No dialog showing, handle interaction with detected action
          //   handleInteraction()
        }
      }
    }
  }

  func onMouseButtonReleased(window: Window, button: Mouse.Button, mods: Keyboard.Modifier) {
    guard Input.player1.isEnabled else { return }

    if showingPickupView {
      // No-op for pickup view
    } else if showingPauseScreen {
      // No-op for pause screen
    } else if showingMainMenu {
      mainMenu.onMouseButtonReleased(window: window, button: button, mods: mods)
    }
  }

  func onScroll(window: Window, xOffset: Double, yOffset: Double) {
    guard Input.player1.isEnabled else { return }

    if showingPickupView {
      pickupView?.onScroll(window: window, xOffset: xOffset, yOffset: yOffset)
    } else if showingPauseScreen {
      // No-op for pause screen
    } else if showingMainMenu {
      mainMenu.onScroll(window: window, xOffset: xOffset, yOffset: yOffset)
    }
  }

  private func showMainMenu(tab: MainMenuTabs.Tab) {
    mainMenu.setActiveTab(tab, animated: false)
    showingMainMenu = true
  }

  private func hideMainMenu() {
    showingMainMenu = false
  }

  private func showPauseScreen() {
    showingPauseScreen = true
    pauseScreenStack.onAttach(window: Engine.shared.window)
  }

  func hidePauseScreen() {
    // Start fade-out animation
    pauseScreenStack.startFadeOut()
    // Don't set showingPauseScreen = false yet - let it fade out first
  }

  private var pickupViewContinuation: CheckedContinuation<Bool, Never>?

  func showPickupView(item: Item, quantity: Int = 1) async -> Bool {
    // Fade to black
    await ScreenFade.shared.fadeToBlack(duration: 0.3)

    // Show view (create and attach)
    pickupView = PickupView(item: item, quantity: quantity)

    // Set up callbacks
    pickupView?.onItemPlaced = { [weak self] slotIndex, placedItem, placedQuantity in
      guard let self = self else { return }
      // Update inventory directly
      if slotIndex < Inventory.player1.slots.count {
        Inventory.player1.slots[slotIndex] = ItemSlotData(
          item: placedItem, quantity: placedQuantity > 1 ? placedQuantity : nil)
      }
      // Resume continuation with success
      self.pickupViewContinuation?.resume(returning: true)
      self.pickupViewContinuation = nil
      // Close pickup view with fade
      Task { await self.hidePickupView() }
    }

    pickupView?.onCancel = { [weak self] in
      guard let self = self else { return }
      // Resume continuation with failure (cancelled)
      self.pickupViewContinuation?.resume(returning: false)
      self.pickupViewContinuation = nil
      // Close pickup view with fade
      Task { await self.hidePickupView() }
    }

    // Attach window
    pickupView?.onAttach(window: Engine.shared.window)

    showingPickupView = true

    // Fade back in
    await ScreenFade.shared.fadeFromBlack(duration: 0.3)

    // Play gong sound when showing pickup view
    UISound.woosh()

    // After fade completes, start slide-in animation
    pickupView?.startSlideInAnimation()

    // Wait for continuation to complete
    return await withCheckedContinuation { continuation in
      self.pickupViewContinuation = continuation
    }
  }

  private func hidePickupView() async {
    // Fade to black
    await ScreenFade.shared.fadeToBlack(duration: 0.3)

    // Hide view
    showingPickupView = false
    pickupView = nil

    // Fade back in
    await ScreenFade.shared.fadeFromBlack(duration: 0.3)

    // Re-enable input after fade completes
    Input.player1.isEnabled = true
  }

  private func loadSceneScript() {
    guard scene != nil else {
      logger.error("‚ö†Ô∏è No scene to load script for")
      return
    }

    // Convert scene name to class name (e.g., "radar_office" -> "RadarOffice", "test" -> "Test")
    let className = sceneNameToClassName(sceneName)

    // Try to load the class using ScriptRegistry
    guard let script = ScriptRegistry.shared.create(className) else {
      logger.error("‚ö†Ô∏è Could not load scene script class: \(className)")
      logger.error("‚ö†Ô∏è Registered classes: \(ScriptRegistry.shared.allRegisteredClasses())")
      return
    }

    sceneScript = script
    logger.trace("‚úÖ Loaded scene script: \(className)")

    // Call sceneDidLoad() after initialization
    sceneScript?.sceneDidLoad()
  }

  /// Convert scene name to class name
  /// Examples: "test" -> "Test", "radar_office" -> "RadarOffice"
  private func sceneNameToClassName(_ sceneName: String) -> String {
    // Split by underscores and capitalize first letter of each word
    let components = sceneName.split(separator: "_")
    let capitalized = components.map { word in
      word.isEmpty ? "" : word.prefix(1).uppercased() + word.dropFirst().lowercased()
    }
    return capitalized.joined()
  }

  /// Normalize entries/camera identifiers so area comparisons stay consistent
  /// - "Entry_1" -> "1"
  /// - "Entry_hallway" -> "hallway"
  /// - "hallway_2" -> "hallway"
  /// - "hallway" -> "hallway"
  /// - "1" -> "1"
  private func normalizedAreaIdentifier(_ name: String) -> String {
    guard !name.isEmpty else { return name }

    var identifier = name

    if identifier.hasPrefix("Entry_") {
      let suffix = identifier.dropFirst("Entry_".count)
      if !suffix.isEmpty {
        identifier = String(suffix)
      }
    }

    if let underscoreIndex = identifier.lastIndex(of: "_") {
      let suffixStart = identifier.index(after: underscoreIndex)
      if suffixStart < identifier.endIndex {
        let suffix = identifier[suffixStart...]
        if suffix.allSatisfy({ $0.isNumber }) {
          identifier = String(identifier[..<underscoreIndex])
        }
      }
    }

    return identifier
  }

  /// Determine the best camera node to activate when loading/transitioning scenes
  private func preferredCameraNodeName(for entry: String, in scene: Scene) -> String? {
    var candidates: [String] = []
    var seen: Set<String> = []

    func addCandidate(_ name: String) {
      guard !name.isEmpty, !seen.contains(name) else { return }
      candidates.append(name)
      seen.insert(name)
    }

    if !entry.hasPrefix("Entry_") {
      addCandidate("Camera_\(entry)_1")
    }

    addCandidate("Camera_1")

    for camera in scene.cameras {
      if let cameraName = camera.name {
        addCandidate(cameraName)
      }
    }

    for candidate in candidates {
      if scene.rootNode.findNode(named: candidate) != nil {
        return candidate
      }
    }

    return nil
  }

  /// Position player at an entry node
  /// - Parameters:
  ///   - entryName: The entry name (e.g., "Entry_1", "hallway" will look for "Entry_hallway")
  ///   - scene: The scene to search for the entry in
  private func positionPlayerAtEntry(_ entryName: String, in scene: Scene) {
    // Try to find entry with exact name first, then try with "Entry_" prefix
    let entryNodeName: String
    if entryName.hasPrefix("Entry_") {
      entryNodeName = entryName
    } else {
      entryNodeName = "Entry_\(entryName)"
    }

    guard let entryNode = scene.rootNode.findNode(named: entryNodeName) else {
      logger.warning("‚ö†Ô∏è Entry node not found: \(entryNodeName)")
      return
    }

    let entryWorld = entryNode.assimpNode.calculateWorldTransform(scene: scene.assimpScene)
    let extractedPos = vec3(entryWorld[3].x, entryWorld[3].y, entryWorld[3].z)
    let fwd = vec3(entryWorld[2].x, entryWorld[2].y, entryWorld[2].z)
    let yaw = atan2(fwd.x, fwd.z)
    let entryRotation = yaw - (.pi * 0.5)

    // The entry position is at the feet, but character controller uses center position
    // Adjust Y position to account for capsule half-height
    let capsuleHalfHeight: Float = 0.8
    let adjustedPos = vec3(extractedPos.x, extractedPos.y + capsuleHalfHeight, extractedPos.z)

    // Update player position and rotation via PlayerController
    playerController.setPosition(adjustedPos, rotation: entryRotation)
    playerController.setSpawn(position: extractedPos, rotation: entryRotation)  // Keep spawn position at feet for reference

    logger.trace("üöÄ Positioned player at \(entryNodeName): \(extractedPos)")
  }

  /// Transition to a different entry in the current scene
  /// - Parameter entry: The entry name (e.g., "hallway", "Entry_2")
  @MainActor func transition(to entry: String) async {
    guard let currentScene = scene else {
      logger.warning("‚ö†Ô∏è Cannot transition: no current scene")
      return
    }

    // Play door open sound before fading out
    UISound.doorOpenA()

    // Fade out
    await ScreenFade.shared.fadeToBlack(duration: 0.3)

    // Position player at entry
    positionPlayerAtEntry(entry, in: currentScene)

    // Try to switch camera based on convention:
    // - Named areas (like "hallway"): try "Camera_hallway_1", fall back to "Camera_1"
    // - Unnamed areas (like "Entry_1"): try "Camera_1"
    let cameraName: String
    let prerenderedCameraName: String
    if entry.hasPrefix("Entry_") {
      // Unnamed area - just use Camera_1
      cameraName = "Camera_1"
      // For prerendered environment, Entry_1 -> "1", Entry_2 -> "2", etc.
      let entrySuffix = String(entry.dropFirst(6))  // Remove "Entry_" prefix
      prerenderedCameraName = entrySuffix
    } else {
      // Named area - try "Camera_{area}_1", fall back to "Camera_1"
      let areaCameraName = "Camera_\(entry)_1"
      if currentScene.rootNode.findNode(named: areaCameraName) != nil {
        cameraName = areaCameraName
        // For prerendered environment, "hallway" -> "hallway_1"
        prerenderedCameraName = "\(entry)_1"
      } else {
        cameraName = "Camera_1"
        prerenderedCameraName = "1"
      }
    }

    // Switch 3D camera
    cameraSystem.syncActiveCamera(name: cameraName)

    // Switch prerendered environment camera
    try? prerenderedEnvironment?.switchToCamera(prerenderedCameraName)
    cameraSystem.selectedCamera = prerenderedEnvironment?.getCurrentCameraName() ?? prerenderedCameraName

    // Reset area tracking - actual area is determined by camera triggers
    currentAreaName = nil

    await Task.sleep(0.15)

    // Fade in
    await ScreenFade.shared.fadeFromBlack(duration: 0.3)

    // Play door close sound after fading in
    UISound.doorCloseA()
  }

  /// Transition to a different scene
  /// - Parameters:
  ///   - scene: The scene name to load
  ///   - entry: Optional entry name (defaults to "Entry_1" if not specified)
  @MainActor func transition(toScene scene: String, entry: String? = nil) async {
    // Play door open sound before fading out
    UISound.doorOpenA()

    // Fade out
    await ScreenFade.shared.fadeToBlack(duration: 0.3)

    // Load the new scene and position at entry (defaults to Entry_1 if not specified)
    let entryName = entry ?? "Entry_1"

    // Determine prerendered camera name based on entry (same logic as transition(to:))
    // We need to determine this before loading the scene, but we'll need the scene to check for named cameras
    // So we'll load with a default and update if needed
    let defaultPrerenderedCameraName: String
    if entryName.hasPrefix("Entry_") {
      // Unnamed area - Entry_1 -> "1", Entry_2 -> "2", etc.
      let entrySuffix = String(entryName.dropFirst(6))  // Remove "Entry_" prefix
      defaultPrerenderedCameraName = entrySuffix
    } else {
      // For named areas, we'll default to "1" and update after scene loads if needed
      defaultPrerenderedCameraName = "1"
    }

    // Load the scene
    await loadScene(scene, entry: entryName, prerenderedCameraName: defaultPrerenderedCameraName)

    // If it's a named area, check if we need to update the camera
    if !entryName.hasPrefix("Entry_"), let currentScene = self.scene {
      let areaCameraName = "Camera_\(entryName)_1"
      if currentScene.rootNode.findNode(named: areaCameraName) != nil {
        let prerenderedCameraName = "\(entryName)_1"
        try? prerenderedEnvironment?.switchToCamera(prerenderedCameraName)
        cameraSystem.selectedCamera = prerenderedEnvironment?.getCurrentCameraName() ?? prerenderedCameraName
        cameraSystem.syncActiveCamera(name: areaCameraName)
      }
    }

    await Task.sleep(0.15)

    // Fade in
    await ScreenFade.shared.fadeFromBlack(duration: 0.3)

    // Play door close sound after fading in
    UISound.doorCloseA()
  }

  /// Load a scene by name, setting up everything (scene, physics, prerendered environment, player position)
  /// - Parameters:
  ///   - sceneName: The scene name to load
  ///   - entry: The entry name to position player at (defaults to "Entry_1")
  ///   - prerenderedCameraName: Optional camera name for prerendered environment (defaults to "1")
  @MainActor func loadScene(_ sceneName: String, entry: String = "Entry_1", prerenderedCameraName: String? = nil) async
  {
    do {
      // Update scene name
      self.sceneName = sceneName

      // Load the scene file
      let scenePath = Bundle.game.path(forResource: "Scenes/\(sceneName)", ofType: "glb")!
      let assimpScene = try Assimp.Scene(
        file: scenePath,
        flags: [.triangulate, .flipUVs, .calcTangentSpace]
      )

      // Wrap in our Scene wrapper
      let scene = Scene(assimpScene)

      print("\(scene.rootNode)")
      //scene.cameras.forEach { logger.trace("\($0)") }

      // Set the scene
      self.scene = scene

      //      // Clear old physics bodies if physics system is ready
      //      guard let physicsSystem = physicsSystem else {
      //        logger.error("‚ö†Ô∏è Physics system not ready, cannot load physics for scene '\(sceneName)'")
      //        return
      //      }

      logger.trace("üîÑ Loading physics for scene '\(sceneName)'...")

      // Update camera system with new scene (prerenderedEnvironment will be set later)
      cameraSystem.setScene(scene)

      // Clear old physics bodies
      physicsWorld.clearAllBodies()
      playerController.clear()
      enemySystem.clearAll()

      // Load new collision bodies
      physicsWorld.loadCollisionBodies(scene: scene)
      physicsWorld.loadActionBodies(scene: scene)
      physicsWorld.loadTriggerBodies(scene: scene)
      physicsWorld.optimizeBroadPhase()
      logger.trace("‚úÖ Loaded physics bodies")

      // Position player at entry (updates player position/rotation)
      // This already adjusts for capsule height, so playerPosition is the center position
      positionPlayerAtEntry(entry, in: scene)

      // Create character controller at the positioned location
      // Use the position that was set by positionPlayerAtEntry (already adjusted for capsule height)
      playerController.create(at: playerPosition, rotation: playerRotation)

      // Mark physics system as ready for updates
      physicsWorld.setReady(true)

      // Load scene script class dynamically
      loadSceneScript()

      // Reset area tracking - camera triggers define actual areas
      currentAreaName = nil

      // Initialize active camera using best available node to avoid missing-camera warnings
      if let preferredCameraName = preferredCameraNodeName(for: entry, in: scene) {
        cameraSystem.syncActiveCamera(name: preferredCameraName)
      } else {
        logger.warning("‚ö†Ô∏è No camera nodes found to sync in scene '\(sceneName)'")
      }

      // Load foreground meshes (nodes with -fg suffix)
      loadForegroundMeshes(scene: scene)

      // Spawn enemies from Enemy_* nodes
      spawnEnemiesFromScene(scene: scene)

      // Initialize prerendered environment for the scene
      let cameraName = prerenderedCameraName ?? "1"
      do {
        prerenderedEnvironment = try PrerenderedEnvironment(sceneName, cameraName: cameraName)
        // Update camera system with prerendered environment (now that it's created)
        cameraSystem.setPrerenderedEnvironment(prerenderedEnvironment)
        // Sync the selectedCamera property with the actual current camera
        cameraSystem.selectedCamera = prerenderedEnvironment?.getCurrentCameraName() ?? cameraName
        if let currentScene = self.scene {
          let activeCameraName = cameraSystem.selectedCamera
          if !activeCameraName.isEmpty {
            let cameraNodeName = "Camera_\(activeCameraName)"
            if currentScene.rootNode.findNode(named: cameraNodeName) != nil {
              cameraSystem.syncActiveCamera(name: cameraNodeName)
            }
          }
        }
      } catch {
        logger.error("‚ö†Ô∏è Failed to initialize PrerenderedEnvironment for scene '\(sceneName)': \(error)")
      }

      // Disable small-room clamping for real scene navigation
      restrictMovementToRoom = false
    } catch {
      logger.error("‚ö†Ô∏è Failed to load scene '\(sceneName)': \(error)")
    }
  }

  @MainActor
  func withScriptCameraOverride<T>(
    on cameraName: String,
    perform: () async throws -> T
  ) async rethrows -> T {
    return try await cameraSystem.withScriptCameraOverride(on: cameraName, perform: perform)
  }

  @MainActor
  func withScriptCameraOverride<T>(
    on cameraName: String,
    perform: () throws -> T
  ) rethrows -> T {
    return try cameraSystem.withScriptCameraOverride(on: cameraName, perform: perform)
  }

  private func drawEntryArrows(scene: Scene, debugRenderer: DebugRenderer) {
    func traverse(_ node: Node) {
      if let name = node.name, name.hasPrefix("Entry_") {
        let world = node.assimpNode.calculateWorldTransform(scene: scene.assimpScene)
        let origin = vec3(world[3].x, world[3].y, world[3].z)
        // Extract forward direction from Z basis vector
        let forwardZ = vec3(world[2].x, world[2].y, world[2].z)
        // Rotate 90¬∞ around Y axis: swap X and Z, negate Z
        // This rotates the forward vector to align with our coordinate system
        let forward = vec3(-forwardZ.z, forwardZ.y, forwardZ.x)

        // Draw arrow using Jolt debug renderer
        let arrowLength: Float = 2.0
        let to = origin + normalize(forward) * arrowLength
        let magentaColor: Jolt.Color = 0xFFFF_00FF  // RGBA: magenta
        debugRenderer.drawArrow(
          from: RVec3(x: origin.x, y: origin.y, z: origin.z),
          to: RVec3(x: to.x, y: to.y, z: to.z),
          color: magentaColor,
          size: 0.5
        )
      }
      for child in node.children { traverse(child) }
    }
    traverse(scene.rootNode)
  }

  func update(window: Window, deltaTime: Float) {
    if showingPickupView {
      // Update pickup view
      pickupView?.update(window: window, deltaTime: deltaTime)
    } else if showingPauseScreen {
      // Update pause screen
      pauseScreenStack.update(deltaTime: deltaTime)
      // Check if fade-out is complete and actually hide the pause screen
      if pauseScreenStack.isFadeOutComplete {
        showingPauseScreen = false
        pauseScreenStack.onDetach(window: Engine.shared.window)
      }
    } else if showingMainMenu {
      // Update main menu
      mainMenu.update(window: window, deltaTime: deltaTime)
    } else {
      // Only handle movement if dialog is not active and input is enabled
      if !dialogView.isActive && Input.player1.isEnabled {
        // Handle WASD movement
        playerController.update(
          keyboard: window.keyboard,
          deltaTime: deltaTime,
          physicsWorld: physicsWorld,
          isAiming: weaponSystem.isAiming
        )

        // Update interaction system (detect actions/triggers)
        interactionSystem.update(
          sceneScript: sceneScript,
          currentAreaName: currentAreaName,
          normalizedAreaIdentifier: normalizedAreaIdentifier
        )

        // Handle weapon system hold mode and firing
        // Update weapon system (for rate of fire timing)
        weaponSystem.update(deltaTime: deltaTime)

        // Update enemy system
        enemySystem.update(deltaTime: deltaTime)

        // Handle hold mode for Space
        if !weaponSystem.usesToggledAiming {
          if window.keyboard.state(of: .space) == .pressed {
            // Space is held - enter ready aim, then aim
            if weaponSystem.currentAimState == .idle {
              weaponSystem.enterReadyAim()
            } else if weaponSystem.currentAimState == .readyAim {
              weaponSystem.enterAim()
            }
          } else {
            // Space released - exit aim
            if weaponSystem.currentAimState != .idle {
              weaponSystem.exitAim()
            }
          }
        }

        // Handle firing with Ctrl (hold to fire)
        if window.keyboard.state(of: .leftControl) == .pressed || window.keyboard.state(of: .rightControl) == .pressed {
          if weaponSystem.isAiming {
            _ = weaponSystem.fire()
          }
        }
      }

      // Update prerendered environment animation
      prerenderedEnvironment?.update()
    }

    // Update dialog view
    dialogView.update(deltaTime: deltaTime)

    // Update FPS (EMA)
    if deltaTime > 0 {
      let inst = 1.0 / deltaTime
      smoothedFPS = smoothedFPS * 0.9 + inst * 0.1
    }
  }

  func draw() {
    if showingPickupView {
      // Draw pickup view
      pickupView?.draw()
    } else if showingMainMenu {
      // Draw main menu
      mainMenu.draw()
    } else {
      // Draw game scene (always, even when paused - pause screen will overlay on top)
      // Set up 3D rendering
      let aspectRatio = Float(Engine.viewportSize.width) / Float(Engine.viewportSize.height)

      // Use Camera_1 projection if available, otherwise fallback to default
      let projection: mat4
      if let camera {
        // Check if camera is orthographic (FOV is 0 or orthographicWidth is set)
        let isOrthographic = camera.horizontalFOV == 0.0 || camera.orthographicWidth > 0.0

        if isOrthographic {
          // Orthographic camera: use orthographicWidth (half width) and aspect ratio
          let orthoWidth = camera.orthographicWidth > 0.0 ? camera.orthographicWidth : 1.0

          // IMPORTANT: Use camera's stored aspect ratio if available, otherwise viewport aspect
          let finalAspect: Float
          if camera.aspect > 0 {
            finalAspect = camera.aspect
          } else {
            finalAspect = aspectRatio
          }

          // Calculate orthographic bounds
          // orthographicWidth is half the horizontal width
          let left = -orthoWidth
          let right = orthoWidth
          // Height = width / aspect, so halfHeight = orthoWidth / aspect
          let bottom = -orthoWidth / finalAspect
          let top = orthoWidth / finalAspect

          projection = GLMath.ortho(left, right, bottom, top, camera.clipPlaneNear, camera.clipPlaneFar)

          logger.trace(
            "üìê Using orthographic camera: width=\(orthoWidth * 2), aspect=\(finalAspect), near=\(camera.clipPlaneNear), far=\(camera.clipPlaneFar)"
          )
        } else {
          // Perspective camera: use existing FOV calculation
          // IMPORTANT: Use camera's stored aspect ratio if available, otherwise viewport aspect
          // The prerendered images were rendered with a specific aspect ratio, so we should match it
          let finalAspect: Float
          if camera.aspect > 0 {
            // Use camera's aspect ratio (this is what the prerendered images were rendered with)
            finalAspect = camera.aspect
          } else {
            // Fallback to viewport aspect ratio
            finalAspect = aspectRatio
          }

          // Convert horizontal FOV to vertical FOV
          // GLMath.perspective expects vertical FOV (fovy), but Assimp gives us horizontal FOV
          // Formula: verticalFOV = 2 * atan(tan(horizontalFOV / 2) / aspectRatio)
          let horizontalFOVHalf = camera.horizontalFOV / 2.0
          let verticalFOV = 2.0 * atan(tan(horizontalFOVHalf) / finalAspect)

          projection = GLMath.perspective(verticalFOV, finalAspect, camera.clipPlaneNear, camera.clipPlaneFar)

          // Debug: Print aspect ratio mismatch if significant
          if abs(finalAspect - aspectRatio) > 0.01 {
            logger.warning("‚ö†Ô∏è Aspect ratio mismatch: camera=\(finalAspect), viewport=\(aspectRatio)")
          }
        }
      } else {
        projection = GLMath.perspective(45.0, aspectRatio, 0.1, 100.0)
      }

      GraphicsContext.current?.renderer.withUIContext {
        // Render prerendered environment first (as background)
        prerenderedEnvironment?.render(projectionMatrix: projection)

        // Clear depth buffer after rendering if debug flag is set
        if disableDepth {
          glClear(GL_DEPTH_BUFFER_BIT)
        }
      }

      // Get view matrix from camera node's world transform
      // In glTF/Assimp, the camera node's transform IS the camera-to-world transform
      // To get the view matrix (world-to-camera), we simply invert it
      var view: mat4
      let cameraWorld: mat4
      // Check if camera world transform is valid (not identity)
      if cameraWorldTransform != mat4(1) {
        cameraWorld = cameraWorldTransform
        // The view matrix is the inverse of the camera's world transform
        // This matches how the prerendered images were rendered
        view = inverse(cameraWorld)
      } else {
        // Fallback: use identity view matrix if camera not available
        cameraWorld = mat4(1)
        view = mat4(1)
      }

      // Apply screen shake offset to view matrix
      let shakeOffset = ScreenShake.shared.offset
      if shakeOffset.x != 0.0 || shakeOffset.y != 0.0 {
        // Translate view matrix by shake offset
        // Convert screen space offset to world space (approximate using viewport size)
        // Scale factor determines how much world space movement corresponds to screen pixels
        let viewportSize = Engine.viewportSize
        let worldOffsetX = shakeOffset.x / viewportSize.width * 10.0  // Scale factor
        let worldOffsetY = shakeOffset.y / viewportSize.height * 10.0  // Scale factor
        view = GLMath.translate(view, vec3(worldOffsetX, worldOffsetY, 0.0))
      }

      // Do not clear depth; we rely on PrerenderedEnvironment writing correct depth

      // Draw capsule mesh
      if !capsuleMeshInstances.isEmpty {
        // Ensure depth testing/writes are enabled for 3D integration
        glEnable(GL_DEPTH_TEST)
        glDepthMask(true)
        glDepthFunc(GL_LEQUAL)

        // Create model matrix: translate to player position, then rotate around Y axis
        // Offset Y downward so capsule sits on floor (assuming origin is at center)
        var adjustedPosition = playerPosition
        adjustedPosition.y -= capsuleHeightOffset
        var modelMatrix = GLMath.translate(mat4(1), adjustedPosition)
        modelMatrix = GLMath.rotate(modelMatrix, playerRotation, vec3(0, 1, 0))

        for meshInstance in capsuleMeshInstances {
          // Combine the mesh's original transform with player transform
          let combinedModelMatrix = modelMatrix * meshInstance.transformMatrix

          // Extract camera position from world transform (4th column)
          let cameraPosition = vec3(cameraWorld[3].x, cameraWorld[3].y, cameraWorld[3].z)

          // Get lighting from scene lights
          let lighting = getSceneLighting()

          meshInstance.draw(
            projection: projection,
            view: view,
            modelMatrix: combinedModelMatrix,
            cameraPosition: cameraPosition,
            lightDirection: lighting.mainLight.direction,
            lightColor: lighting.mainLight.color,
            lightIntensity: lighting.mainLight.intensity,
            fillLightDirection: lighting.fillLight.direction,
            fillLightColor: lighting.fillLight.color,
            fillLightIntensity: lighting.fillLight.intensity,
            diffuseOnly: false
          )
        }
      }

      // Draw enemy capsules
      let aliveEnemies = enemySystem.aliveEnemies
      if !aliveEnemies.isEmpty && !capsuleMeshInstances.isEmpty {
        glEnable(GL_DEPTH_TEST)
        glDepthMask(true)
        glDepthFunc(GL_LEQUAL)

        let lighting = getSceneLighting()
        let cameraPosition = vec3(cameraWorld[3].x, cameraWorld[3].y, cameraWorld[3].z)

        for enemy in aliveEnemies {
          // Create model matrix: translate to enemy position, then rotate around Y axis
          // Offset Y downward so capsule sits on floor (assuming origin is at center)
          var adjustedPosition = enemy.position
          adjustedPosition.y -= capsuleHeightOffset
          var modelMatrix = GLMath.translate(mat4(1), adjustedPosition)
          modelMatrix = GLMath.rotate(modelMatrix, enemy.rotation, vec3(0, 1, 0))

          for meshInstance in capsuleMeshInstances {
            // Combine the mesh's original transform with enemy transform
            let combinedModelMatrix = modelMatrix * meshInstance.transformMatrix

            // Use a slightly different color to distinguish from player (tint red)
            meshInstance.draw(
              projection: projection,
              view: view,
              modelMatrix: combinedModelMatrix,
              cameraPosition: cameraPosition,
              lightDirection: lighting.mainLight.direction,
              lightColor: lighting.mainLight.color,
              lightIntensity: lighting.mainLight.intensity,
              fillLightDirection: lighting.fillLight.direction,
              fillLightColor: lighting.fillLight.color,
              fillLightIntensity: lighting.fillLight.intensity,
              diffuseOnly: false
            )
          }
        }
      }

      // Draw foreground meshes (nodes with -fg suffix)
      if !foregroundMeshInstances.isEmpty {
        glEnable(GL_DEPTH_TEST)
        glDepthMask(true)
        glDepthFunc(GL_LEQUAL)

        let lighting = getSceneLighting()
        let cameraPosition = vec3(cameraWorld[3].x, cameraWorld[3].y, cameraWorld[3].z)

        for meshInstance in foregroundMeshInstances {
          // Skip if not visible (node is hidden)
          guard meshInstance.isVisible() else { continue }

          meshInstance.draw(
            projection: projection,
            view: view,
            modelMatrix: meshInstance.transformMatrix,
            cameraPosition: cameraPosition,
            lightDirection: lighting.mainLight.direction,
            lightColor: lighting.mainLight.color,
            lightIntensity: lighting.mainLight.intensity,
            fillLightDirection: lighting.fillLight.direction,
            fillLightColor: lighting.fillLight.color,
            fillLightIntensity: lighting.fillLight.intensity,
            diffuseOnly: false
          )
        }
      }

      // Always call nextFrame to maintain consistent timing (even when not visualizing)
      physicsWorld.nextFrame()

      if !showingPauseScreen {
        // Update debug renderer camera and draw if enabled
        if let debugRenderer = physicsWorld.getDebugRenderer() {
          currentProjection = projection
          currentView = view

          // Set camera position for debug renderer (extract from view matrix)
          let cameraPosition = vec3(cameraWorld[3].x, cameraWorld[3].y, cameraWorld[3].z)
          debugRenderer.setCameraPosition(RVec3(x: cameraPosition.x, y: cameraPosition.y, z: cameraPosition.z))

          if visualizePhysics {
            debugRenderer.drawMarker(RVec3(x: 0, y: 0, z: 0), color: 0xFFFF00FF, size: 2.0)
            physicsWorld.drawBodies(debugRenderer: debugRenderer)

            // Draw character controllers (player and enemies)
            // Player character controller
            if let characterController = playerController.getCharacterController() {
              let worldTransform = characterController.getWorldTransform()
              // Draw capsule: halfHeight 0.8, radius 0.4
              debugRenderer.drawCapsule(
                worldTransform,
                halfHeightOfCylinder: 0.8,
                radius: 0.4,
                color: 0xFF00FF00,  // Green for player
                castShadow: .off,
                drawMode: .wireframe
              )
            }

            // Enemy character controllers
            for enemy in enemySystem.aliveEnemies {
              if let characterController = enemy.characterController {
                let worldTransform = characterController.getWorldTransform()
                // Determine capsule size based on enemy type
                let (halfHeight, radius): (Float, Float)
                if enemy is DogEnemy {
                  halfHeight = 0.4
                  radius = 0.25
                } else {
                  halfHeight = 0.8
                  radius = 0.4
                }
                // Red for enemies
                debugRenderer.drawCapsule(
                  worldTransform,
                  halfHeightOfCylinder: halfHeight,
                  radius: radius,
                  color: 0xFFFF0000,  // Red for enemies
                  castShadow: .off,
                  drawMode: .wireframe
                )
              }
            }

            // Draw gun ray if available
            if let rayInfo = weaponSystem.getLastRayInfo() {
              let rayStart = vec3(rayInfo.origin.x, rayInfo.origin.y, rayInfo.origin.z)
              let rayEnd =
                rayStart + vec3(rayInfo.direction.x, rayInfo.direction.y, rayInfo.direction.z) * rayInfo.range
              debugRenderer.drawLine(
                from: rayInfo.origin,
                to: RVec3(x: rayEnd.x, y: rayEnd.y, z: rayEnd.z),
                color: 0xFFFFFF00  // Yellow for gun ray
              )
            }
          }

          // Draw entry arrows using Jolt debug renderer
          if visualizeEntries, let loadedScene = scene {
            drawEntryArrows(scene: loadedScene, debugRenderer: debugRenderer)
          }
        }

        // Debug overlay (top-left)
        if showDebugText {
          drawDebugInfo()
        }

        // Enemy debug overlay (health bars and state labels)
        if showEnemyDebugOverlay {
          drawEnemyDebugOverlay(projection: projection, view: view)
        }

        // Draw dialog view (on top of everything)
        GraphicsContext.current?.renderer.withUIContext {
          dialogView.draw()
        }
      }
    }

    // Draw pause screen as overlay on top of game (if showing)
    if showingPauseScreen {
      pauseScreenStack.draw()
    }
  }

  private func drawDebugInfo() {
    let cameraDisplayName: String
    if cameraSystem.isDebugCameraOverrideMode {
      cameraDisplayName = "\(selectedCamera) (override)"
    } else {
      cameraDisplayName = selectedCamera
    }

    let sceneLine: String
    if let areaName = currentAreaName, !areaName.isEmpty {
      sceneLine = "Scene: \(sceneName) (\(areaName))"
    } else {
      sceneLine = "Scene: \(sceneName)"
    }

    var overlayLines = [
      //String(format: "FPS: %.0f", smoothedFPS),
      sceneLine,
      "Camera: \(cameraDisplayName)",

      String(
        format: "Position: %.2f, %.2f, %.2f",
        playerPosition.x,
        playerPosition.y,
        playerPosition.z
      ),

      String(
        format: "Rotation: %.0f¬∞ (%.2f rad)",
        playerRotation * 180.0 / .pi,
        playerRotation
      ),

      interactionSystem.detectedActionName != nil
        ? "Actions: \(interactionSystem.detectedActionName!.prefix(1).lowercased() + interactionSystem.detectedActionName!.dropFirst())"
        : "Actions: none",

      interactionSystem.currentTriggers.isEmpty
        ? "Triggers: none"
        : "Triggers: \(interactionSystem.currentTriggers.map { $0.prefix(1).lowercased() + $0.dropFirst() }.joined(separator: ", "))",
    ]

    // Add camera triggers line if there are any
    if !interactionSystem.currentCameraTriggers.isEmpty {
      overlayLines.append(
        "Camera Triggers: \(interactionSystem.currentCameraTriggers.map { $0.prefix(1).lowercased() + $0.dropFirst() }.joined(separator: ", "))"
      )
    }

    let overlay = overlayLines.joined(separator: "\n")

    overlay.draw(
      at: Point(20, Engine.viewportSize.height - 20),
      style: .itemDescription.withMonospacedDigits(true),
      anchor: .topLeft
    )
  }

  private func projectToScreen(position: vec3, projection: mat4, view: mat4, viewportSize: Size) -> Point? {
    let worldPos = vec4(position.x, position.y, position.z, 1.0)
    let clipPos = projection * view * worldPos
    guard abs(clipPos.w) > 0.0001 else { return nil }

    let ndcX = clipPos.x / clipPos.w
    let ndcY = clipPos.y / clipPos.w
    guard ndcX.isFinite && ndcY.isFinite else { return nil }

    let halfWidth = viewportSize.width * 0.5
    let halfHeight = viewportSize.height * 0.5
    let screenX = halfWidth + ndcX * halfWidth
    let screenY = halfHeight + ndcY * halfHeight
    return Point(screenX, screenY)
  }

  private func drawEnemyDebugOverlay(projection: mat4, view: mat4) {
    let viewportSize = Engine.viewportSize
    let aliveEnemies = enemySystem.aliveEnemies

    for enemy in aliveEnemies {
      // Position above enemy (adjust Y offset based on enemy type)
      let yOffset: Float = enemy is DogEnemy ? 0.6 : 1.2
      let worldPosition = vec3(enemy.position.x, enemy.position.y + yOffset, enemy.position.z)

      guard
        let screenPoint = projectToScreen(
          position: worldPosition,
          projection: projection,
          view: view,
          viewportSize: viewportSize
        )
      else { continue }

      // Skip if off-screen
      guard screenPoint.x >= -50 && screenPoint.x <= viewportSize.width + 50,
        screenPoint.y >= -50 && screenPoint.y <= viewportSize.height + 50
      else { continue }

      // Draw health bar
      let barWidth: Float = 60.0
      let barHeight: Float = 6.0
      let healthPercent = enemy.health / enemy.maxHealth

      // Background (red/dark)
      let bgRect = Rect(
        x: screenPoint.x - barWidth * 0.5,
        y: screenPoint.y - 20,
        width: barWidth,
        height: barHeight
      )
      bgRect.fill(with: Color(red: 0.3, green: 0.0, blue: 0.0, alpha: 0.8))

      // Health (green)
      let healthWidth = barWidth * healthPercent
      if healthWidth > 0 {
        let healthRect = Rect(
          x: screenPoint.x - barWidth * 0.5,
          y: screenPoint.y - 20,
          width: healthWidth,
          height: barHeight
        )
        healthRect.fill(with: Color(red: 0.0, green: 0.8, blue: 0.0, alpha: 0.9))
      }

      // Border
      bgRect.frame(with: Color(red: 1.0, green: 1.0, blue: 1.0, alpha: 0.9), lineWidth: 1.0)

      // State label
      let stateString: String
      switch enemy.state {
      case .idle: stateString = "Idle"
      case .patrolling: stateString = "Patrol"
      case .chasing: stateString = "Chase"
      case .attacking: stateString = "Attack"
      case .dead: stateString = "Dead"
      }

      stateString.draw(
        at: Point(screenPoint.x, screenPoint.y - 35),
        style: .itemDescription.withMonospacedDigits(true),
        anchor: .center
      )
    }
  }

}
