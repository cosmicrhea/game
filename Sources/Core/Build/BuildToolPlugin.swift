import Foundation
import PackagePlugin

@main
struct BuildToolPlugin: PackagePlugin.BuildToolPlugin {
  func createBuildCommands(context: PluginContext, target: Target) async throws -> [Command] {
    let versionOutputFile = context.pluginWorkDirectoryURL.appendingPathComponent("Version.swift")
    let versionScriptFile = context.pluginWorkDirectoryURL.appendingPathComponent("generate_version.sh")

    let registrationOutputFile = context.pluginWorkDirectoryURL.appendingPathComponent("SceneScriptRegistration.swift")
    let registrationScriptFile = context.pluginWorkDirectoryURL.appendingPathComponent("generate_registration.sh")
    let scenesDirectory = context.package.directoryURL.appendingPathComponent("Sources/Scenes")

    // Localization conversion setup
    // Output to plugin work directory first, then copy to Assets/Localizations
    let xcstringsInput = context.package.directoryURL.appendingPathComponent("Assets/Localizable.xcstrings")
    let localizationTempDir = context.pluginWorkDirectoryURL.appendingPathComponent("Localizations")
    let localizationOutputDir = context.package.directoryURL.appendingPathComponent("Assets/Localizations")
    let convertScript = context.pluginWorkDirectoryURL.appendingPathComponent("ConvertXCStrings.swift")

    // Create a shell script that will work better with Xcode
    let versionScriptContent = """
      #!/bin/sh
      set -e

      # Get git commit count
      COMMIT_COUNT=$(git rev-list --count HEAD 2>/dev/null || echo "0")

      # Generate version information
      MAJOR_VERSION=0
      MINOR_VERSION=$COMMIT_COUNT
      VERSION_STRING="$MAJOR_VERSION.$MINOR_VERSION"

      # Generate the Swift file
      cat > "\(versionOutputFile.path)" << EOF
      // Auto-generated version information
      // Generated on: $(date)
      // Commit count: $COMMIT_COUNT

      extension Engine {
          public static let versionMajor = $MAJOR_VERSION
          public static let versionMinor = $MINOR_VERSION
          public static let versionPatch = 0
          
          public static let versionString = "$VERSION_STRING"
          public static let versionFullString = "$VERSION_STRING.0"
          
          public static let commitCount = $COMMIT_COUNT
      }
      EOF

      echo "Generated version: $VERSION_STRING (commit count: $COMMIT_COUNT)"
      """

    // Create script to scan for @SceneScript classes and generate registration
    let registrationScriptContent = """
      #!/bin/sh
      set -e

      PACKAGE_DIR="\(context.package.directoryURL.path)"
      SCENES_DIR="$PACKAGE_DIR/Sources/Scenes"

      # Find all Swift files in Sources/Scenes that contain @SceneScript
      SCENE_SCRIPTS=""
      if [ -d "$SCENES_DIR" ]; then
        SCENE_SCRIPTS=$(find "$SCENES_DIR" -name "*.swift" -type f 2>/dev/null | xargs grep -l "@SceneScript" 2>/dev/null || true)
      fi

      # Extract class names from files with @SceneScript
      CLASSES=""
      if [ -n "$SCENE_SCRIPTS" ]; then
        for file in $SCENE_SCRIPTS; do
          # Extract class name after @SceneScript (look for "class ClassName:")
          CLASS_NAME=$(grep -A 1 "@SceneScript" "$file" 2>/dev/null | grep -E "^class [A-Za-z][A-Za-z0-9_]*" | sed 's/^class \\([A-Za-z][A-Za-z0-9_]*\\).*/\\1/' || true)
          if [ -n "$CLASS_NAME" ]; then
            CLASSES="$CLASSES $CLASS_NAME"
          fi
        done
      fi

      # Function to convert PascalCase to snake_case (macOS compatible)
      # e.g., "ChiefsOffice" -> "chiefs_office", "Nexus" -> "nexus"
      pascal_to_snake() {
        echo "$1" | sed 's/\\([A-Z]\\)/_\\1/g' | sed 's/^_//' | tr '[:upper:]' '[:lower:]'
      }

      # Function to convert PascalCase to camelCase (macOS compatible)
      # e.g., "ChiefsOffice" -> "chiefsOffice", "Nexus" -> "nexus"
      pascal_to_camel() {
        local first_char=$(echo "$1" | cut -c1 | tr '[:upper:]' '[:lower:]')
        local rest=$(echo "$1" | cut -c2-)
        echo "${first_char}${rest}"
      }

      # Generate registration code that will be embedded in ScriptHotReload.swift
      # We'll generate a function that calls _register() on each script class
      cat > "\(registrationOutputFile.path)" << 'REGEOF'
      // Auto-generated scene script registration
      // Generated on: $(date)
      // This file is automatically generated - do not edit manually

      import Foundation

      @MainActor
      func registerAllSceneScripts() {
        // Register all @SceneScript classes
        logger.trace("ðŸ”„ registerAllSceneScripts() called")
      REGEOF

      if [ -n "$CLASSES" ]; then
        for class_name in $CLASSES; do
          echo "  $class_name._register()" >> "\(registrationOutputFile.path)"
        done
      fi

      cat >> "\(registrationOutputFile.path)" << 'REGEOF'
      }

      /// Auto-generated enum of all scene names
      /// Use with `goTo(scene: .sceneName)` for type-safe scene navigation
      extension Scene {
        enum Name: String, CaseIterable {
      REGEOF

      # Generate enum cases for each scene
      if [ -n "$CLASSES" ]; then
        for class_name in $CLASSES; do
          # Convert PascalCase class name to snake_case scene name
          scene_name=$(pascal_to_snake "$class_name")
          # The enum case name should be camelCase (first letter lowercase)
          case_name=$(pascal_to_camel "$class_name")
          echo "    case $case_name = \\\"$scene_name\\\"" >> "\(registrationOutputFile.path)"
        done
      fi

      cat >> "\(registrationOutputFile.path)" << 'REGEOF'
        }
      }
      REGEOF

      # Also generate a simple list of class names for direct registration
      cat > "\(registrationOutputFile.path).classes" << 'CLASSEOF'
      // Auto-generated list of scene script class names
      // Generated on: $(date)
      // This file is automatically generated - do not edit manually
      CLASSEOF

      if [ -n "$CLASSES" ]; then
        for class_name in $CLASSES; do
          echo "$class_name" >> "\(registrationOutputFile.path).classes"
        done
      fi

      if [ -n "$CLASSES" ]; then
        echo "Generated scene script registration with classes: $CLASSES"
      else
        echo "No @SceneScript classes found - generated empty registration"
      fi
      """

    // Copy the conversion script to plugin work directory
    let convertScriptSource = context.package.directoryURL.appendingPathComponent(
      ".scripts/ConvertXCStrings.swift")
    let convertScriptContent = try String(contentsOf: convertScriptSource, encoding: .utf8)
    try convertScriptContent.write(to: convertScript, atomically: true, encoding: .utf8)

    // Create shell script wrapper for localization conversion
    let localizationScriptContent = """
      #!/bin/sh
      set -e

      XCSTRINGS_FILE="\(xcstringsInput.path)"
      CONVERT_SCRIPT="\(convertScript.path)"

      if [ ! -f "$XCSTRINGS_FILE" ]; then
        echo "Warning: Localizable.xcstrings not found at $XCSTRINGS_FILE"
        exit 0
      fi

      # Write to temp directory first
      TEMP_DIR="\(localizationTempDir.path)"
      OUTPUT_DIR="\(localizationOutputDir.path)"

      # Ensure temp directory exists
      mkdir -p "$TEMP_DIR"

      # Run the conversion script to temp directory
      swift "$CONVERT_SCRIPT" "$XCSTRINGS_FILE" "$TEMP_DIR"

      # Copy generated files to final location for SwiftPM resource inclusion
      # Note: Files are already in the bundle via build tool outputs, but we also
      # copy to Assets/Localizations so SwiftPM can include them as declared resources
      mkdir -p "$OUTPUT_DIR" 2>/dev/null || true

      # Try to copy, but don't fail if it doesn't work (files are already in bundle)
      if [ -d "$TEMP_DIR" ] && [ -w "$OUTPUT_DIR" ] 2>/dev/null; then
        find "$OUTPUT_DIR" -maxdepth 1 -type d -name "*.lproj" -exec rm -rf {} + 2>/dev/null || true
        for lproj_dir in "$TEMP_DIR"/*.lproj; do
          if [ -d "$lproj_dir" ] && [ -f "$lproj_dir/Localizable.strings" ]; then
            lang_name=$(basename "$lproj_dir")
            target_dir="$OUTPUT_DIR/$lang_name"
            rm -rf "$target_dir" 2>/dev/null || true
            mkdir -p "$target_dir" 2>/dev/null || true
            cat "$lproj_dir/Localizable.strings" > "$target_dir/Localizable.strings" 2>/dev/null || true
          fi
        done
      fi
      """

    let localizationScriptFile = context.pluginWorkDirectoryURL.appendingPathComponent("convert_localization.sh")
    try localizationScriptContent.write(to: localizationScriptFile, atomically: true, encoding: .utf8)

    // Parse the xcstrings file to determine which languages exist
    var localizationOutputFiles: [URL] = []
    if FileManager.default.fileExists(atPath: xcstringsInput.path) {
      do {
        let data = try Data(contentsOf: xcstringsInput)
        if let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
          let strings = json["strings"] as? [String: Any],
          let sourceLanguage = json["sourceLanguage"] as? String
        {
          var languages: Set<String> = [sourceLanguage]

          // Extract all languages from localizations
          for (_, entry) in strings {
            if let entryDict = entry as? [String: Any],
              let localizations = entryDict["localizations"] as? [String: Any]
            {
              for lang in localizations.keys {
                languages.insert(lang)
              }
            }
          }

          // Create output file URLs for each language (in temp dir for build tracking)
          for lang in languages {
            let lprojDir = localizationTempDir.appendingPathComponent("\(lang).lproj")
            let stringsFile = lprojDir.appendingPathComponent("Localizable.strings")
            localizationOutputFiles.append(stringsFile)
          }
        }
      } catch {
        // If parsing fails, we'll still try to run the conversion
        print("Warning: Could not parse xcstrings file to determine languages: \(error)")
      }
    }

    // If no output files were determined, use a marker file approach
    if localizationOutputFiles.isEmpty {
      let markerFile = localizationOutputDir.appendingPathComponent(".localization_complete")
      localizationOutputFiles.append(markerFile)
    }

    // Collect all Swift files in Sources/Scenes as input files for registration
    var sceneScriptInputFiles: [URL] = []
    if FileManager.default.fileExists(atPath: scenesDirectory.path) {
      let enumerator = FileManager.default.enumerator(
        at: scenesDirectory,
        includingPropertiesForKeys: nil,
        options: [.skipsHiddenFiles]
      )
      while let fileURL = enumerator?.nextObject() as? URL {
        if fileURL.pathExtension == "swift" {
          sceneScriptInputFiles.append(fileURL)
        }
      }
    }

    // Write the scripts to temporary files
    try versionScriptContent.write(to: versionScriptFile, atomically: true, encoding: String.Encoding.utf8)
    try registrationScriptContent.write(to: registrationScriptFile, atomically: true, encoding: String.Encoding.utf8)

    return [
      .buildCommand(
        displayName: "Generate Version Information",
        executable: URL(fileURLWithPath: "/bin/sh"),
        arguments: [versionScriptFile.path],
        outputFiles: [versionOutputFile]
      ),
      .buildCommand(
        displayName: "Generate Scene Script Registration",
        executable: URL(fileURLWithPath: "/bin/sh"),
        arguments: [registrationScriptFile.path],
        inputFiles: sceneScriptInputFiles,
        outputFiles: [registrationOutputFile]
      ),
      .buildCommand(
        displayName: "Convert XCStrings to .strings Plist Files",
        executable: URL(fileURLWithPath: "/bin/sh"),
        arguments: [localizationScriptFile.path],
        inputFiles: [xcstringsInput],
        outputFiles: localizationOutputFiles
      ),
    ]
  }
}
