import Assimp

/// Macro to automatically generate method registry and dynamic calling for scene scripts
@attached(
  member, names: named(methodRegistry), named(availableMethods), named(callMethod), named(_register),
  named(_autoRegister), named(validateRefs))
public macro SceneScript() = #externalMacro(module: "GameMacros", type: "SceneScriptMacro")

/// Macro to automatically find a node from the scene
/// Usage: `@Ref var catStatue: Node!` or `@Ref("StatueOfCat") var catStatue: Node!`
@attached(accessor)
@attached(peer, names: arbitrary)
public macro Ref(_ nodeName: String? = nil) = #externalMacro(module: "GameMacros", type: "RefMacro")

/// Macro to automatically persist script-scoped flags using the ScriptFlagStore.
@attached(accessor)
public macro Flag(_ name: String? = nil) = #externalMacro(module: "GameMacros", type: "FlagMacro")

class Character {

  func play(animation animationName: String) {}

  func teleport(to waypointName: String) {}
  func walk(to waypointName: String) {}
  func run(to waypointName: String) {}

}

@MainActor
class Script {

  var scene: Scene {
    guard let mainLoop = MainLoop.shared else {
      fatalError("MainLoop.shared is nil - ensure MainLoop.init() has been called")
    }
    guard let scene = mainLoop.scene else {
      fatalError("MainLoop.shared.scene is nil - ensure loadScene() has been called")
    }
    return scene
  }

  var dialogView: DialogView {
    guard let mainLoop = MainLoop.shared else {
      fatalError("MainLoop.shared is nil - ensure MainLoop.init() has been called")
    }
    return mainLoop.dialogView
  }

  var flags: ScriptFlagStore {
    guard let mainLoop = MainLoop.shared else {
      fatalError("MainLoop.shared is nil - ensure MainLoop.init() has been called")
    }
    return mainLoop.flagStore
  }

  private var flagNamespace: String {
    return String(describing: type(of: self))
  }

  func flagKey(_ suffix: String) -> String {
    return "\(flagNamespace)/\(suffix)"
  }

  func readFlag<T: ScriptFlagValue>(_ name: String, default defaultValue: T) -> T {
    return flags.value(forKey: flagKey(name), default: defaultValue)
  }

  func writeFlag<T: ScriptFlagValue>(_ value: T, name: String) {
    flags.set(value, forKey: flagKey(name))
  }

  func hasFlag(_ name: String) -> Bool {
    return flags.containsValue(forKey: flagKey(name))
  }

  func clearFlag(_ name: String) {
    flags.removeValue(forKey: flagKey(name))
  }

  func setFlag(_ name: String, to value: Bool = true) {
    writeFlag(value, name: name)
  }

  func flagValue(_ name: String, default defaultValue: Bool = false) -> Bool {
    return readFlag(name, default: defaultValue)
  }

  /// Track the current action name (set by MainLoop before calling interaction methods)
  var currentActionName: String?

  /// Track the current area/zone the player is in (set automatically when transitioning)
  /// Stored on MainLoop so gameplay systems can query it directly.
  var currentArea: String? {
    get { MainLoop.shared?.currentAreaName }
    set { MainLoop.shared?.currentAreaName = newValue }
  }

  /// Track interaction counts for variations cycling
  private var interactionCounts: [String: Int] = [:]
  /// Track call counters per action (resets each interaction)
  private var sayCallCounters: [String: Int] = [:]

  /// Reset the call counter for an action (called at the start of each interaction)
  func resetCallCounter(for actionName: String) {
    sayCallCounters[actionName] = 0
  }

  //private var storageView = StorageView()

  var hasAliveEnemies: Bool { false }

  /// Called when the scene script is loaded and initialized
  /// Override this method in scene-specific script classes to perform initialization
  func sceneDidLoad() {}

  /// Validates all @Ref properties by eagerly accessing them.
  /// Override generated by @SceneScript macro.
  /// Called automatically before sceneDidLoad() to catch missing nodes/cameras early.
  func validateRefs() {
    // Base implementation does nothing - overridden by @SceneScript macro
  }

  /// Find a node by name, searching from the root node
  /// Matches exact names or names with dashed suffixes (e.g., "CatStatue" matches "CatStatue-fg")
  func findNode(_ name: String) -> Node? {
    return findNode(named: name, in: scene.rootNode)
  }

  private func findNode(named name: String, in node: Node) -> Node? {
    // Check if this node matches (exact match or starts with name followed by dash)
    if let nodeName = node.name {
      if nodeName == name || nodeName.hasPrefix("\(name)-") {
        return node
      }
    }

    // Recursively search children
    for child in node.children {
      if let found = findNode(named: name, in: child) {
        return found
      }
    }

    return nil
  }

  /// Find a camera by name
  /// The name should match the camera's name property (e.g., "Camera_desk" or "desk" -> "Camera_desk")
  /// Tries exact match, then with Camera_ prefix, then lowercase variations
  func findCamera(_ name: String) -> Assimp.Camera? {
    // Try exact match first
    if let camera = scene.cameras.first(where: { $0.name == name }) {
      return camera
    }

    // Try with Camera_ prefix if not already present
    let cameraName = name.hasPrefix("Camera_") ? name : "Camera_\(name)"
    if let camera = scene.cameras.first(where: { $0.name == cameraName }) {
      return camera
    }

    // Try lowercase version (e.g., "Camera_Desk" -> "Camera_desk")
    let lowercaseName = cameraName.lowercased()
    if lowercaseName != cameraName {
      return scene.cameras.first(where: { $0.name == lowercaseName })
    }

    return nil
  }

  func loadScene(_ name: String, entry entryName: String? = nil) {}

  /// Transition to a different entry in the current scene
  /// - Parameter entry: The entry name (e.g., "hallway", "Entry_2")
  @MainActor func goTo(entry entryName: String) {
    guard let mainLoop = MainLoop.shared else {
      logger.warning("⚠️ Cannot transition: MainLoop.shared is nil")
      return
    }
    Task {
      await mainLoop.transition(to: entryName)
    }
  }

  /// Transition to a different entry in the current scene (async version that waits for completion)
  /// - Parameter entry: The entry name (e.g., "hallway", "Entry_2")
  @MainActor func goTo(entry entryName: String) async {
    guard let mainLoop = MainLoop.shared else {
      logger.warning("⚠️ Cannot transition: MainLoop.shared is nil")
      return
    }
    await mainLoop.transition(to: entryName)
  }

  /// Transition to a different scene
  /// - Parameters:
  ///   - scene: The scene name to load
  ///   - entry: Optional entry name (defaults to "Entry_1" if not specified)
  @MainActor func goTo(scene sceneName: String, entry: String? = nil) {
    guard let mainLoop = MainLoop.shared else {
      logger.warning("⚠️ Cannot transition: MainLoop.shared is nil")
      return
    }
    Task {
      await mainLoop.transition(toScene: sceneName, entry: entry)
    }
  }

  /// Transition to a different scene (async version that waits for completion)
  /// - Parameters:
  ///   - scene: The scene name to load
  ///   - entry: Optional entry name (defaults to "Entry_1" if not specified)
  @MainActor func goTo(scene sceneName: String, entry: String? = nil) async {
    guard let mainLoop = MainLoop.shared else {
      logger.warning("⚠️ Cannot transition: MainLoop.shared is nil")
      return
    }
    await mainLoop.transition(toScene: sceneName, entry: entry)
  }

  /// Transition to a different scene (type-safe version)
  /// - Parameters:
  ///   - scene: The scene to load (from auto-generated Scene.Name enum)
  ///   - entry: Optional entry name (defaults to "Entry_1" if not specified)
  @MainActor func goTo(scene: Scene.Name, entry: String? = nil) {
    goTo(scene: scene.rawValue, entry: entry)
  }

  /// Transition to a different scene (async type-safe version that waits for completion)
  /// - Parameters:
  ///   - scene: The scene to load (from auto-generated Scene.Name enum)
  ///   - entry: Optional entry name (defaults to "Entry_1" if not specified)
  @MainActor func goTo(scene: Scene.Name, entry: String? = nil) async {
    await goTo(scene: scene.rawValue, entry: entry)
  }

  /// Runs work while forcing the camera to a specific closeup.
  /// Camera triggers are temporarily ignored until the closure finishes.
  /// - Parameters:
  ///   - cameraName: Name of the camera trigger/cut (e.g., "stove.001" or "Entry_1").
  ///   - perform: The work to execute during the closeup.
  @discardableResult
  func withCloseup<T>(on cameraName: String, perform: () throws -> T) rethrows -> T {
    guard let mainLoop = MainLoop.shared else {
      logger.warning("⚠️ Cannot activate closeup '\(cameraName)': MainLoop.shared is nil")
      return try perform()
    }
    return try mainLoop.withScriptCameraOverride(on: cameraName, perform: perform)
  }

  /// Runs work while forcing the camera to a specific closeup.
  /// Camera triggers are temporarily ignored until the closure finishes.
  /// - Parameters:
  ///   - camera: The camera object to use for the closeup.
  ///   - perform: The work to execute during the closeup.
  @discardableResult
  func withCloseup<T>(on camera: Assimp.Camera, perform: () throws -> T) rethrows -> T {
    guard let cameraName = camera.name else {
      logger.warning("⚠️ Cannot activate closeup: camera has no name")
      return try perform()
    }
    return try withCloseup(on: cameraName, perform: perform)
  }

  /// Async variant of `withCloseup(on:perform:)`.
  @discardableResult
  func withCloseup<T>(on cameraName: String, perform: () async throws -> T) async rethrows -> T {
    guard let mainLoop = MainLoop.shared else {
      logger.warning("⚠️ Cannot activate closeup '\(cameraName)': MainLoop.shared is nil")
      return try await perform()
    }
    return try await mainLoop.withScriptCameraOverride(on: cameraName, perform: perform)
  }

  /// Async variant of `withCloseup(on:perform:)`.
  @discardableResult
  func withCloseup<T>(on camera: Assimp.Camera, perform: () async throws -> T) async rethrows -> T {
    guard let cameraName = camera.name else {
      logger.warning("⚠️ Cannot activate closeup: camera has no name")
      return try await perform()
    }
    return try await withCloseup(on: cameraName, perform: perform)
  }

  @MainActor func say(_ string: LocalizedStringResource, more: Bool = false) {
    dialogView.print(chunks: [string], forceMore: more)
  }

  @MainActor func say(_ strings: [LocalizedStringResource], more: Bool = false) {
    dialogView.print(chunks: strings, forceMore: more)
  }

  /// Async version of say() that waits until the dialog is finished
  /// - Parameter string: The text to display
  /// - Parameter more: If true, forces the more indicator to show even if there are no more chunks
  @MainActor func say(_ string: LocalizedStringResource, more: Bool = false) async {
    await dialogView.print(chunks: [string], forceMore: more)
  }

  /// Async version of say() that waits until the dialog is finished
  /// - Parameter strings: Array of text chunks to display
  /// - Parameter more: If true, forces the more indicator to show even if there are no more chunks
  @MainActor func say(_ strings: [LocalizedStringResource], more: Bool = false) async {
    await dialogView.print(chunks: strings, forceMore: more)
  }

  /// Say text with variations that cycle through on repeated interactions
  /// - Parameter variations: Array of text variations to cycle through
  /// The variations loop back to the first after exhausting all options
  @MainActor func say(variations: [LocalizedStringResource]) {
    guard !variations.isEmpty else { return }

    // Use currentActionName if available, otherwise fall back to #function
    let actionName = currentActionName ?? #function

    // Get and increment the call counter for this action
    let callIndex = sayCallCounters[actionName, default: 0]
    sayCallCounters[actionName] = callIndex + 1

    // Use action name + call index as the key
    let key = "\(actionName):\(callIndex)"
    let count = interactionCounts[key, default: 0]
    let index = count % variations.count
    let text = variations[index]

    interactionCounts[key] = count + 1

    say(text)
  }

  /// Async version of say(variations:) that waits until the dialog is finished
  /// - Parameter variations: Array of text variations to cycle through
  /// The variations loop back to the first after exhausting all options
  @MainActor func say(variations: [LocalizedStringResource]) async {
    guard !variations.isEmpty else { return }

    // Use currentActionName if available, otherwise fall back to #function
    let actionName = currentActionName ?? #function

    // Get and increment the call counter for this action
    let callIndex = sayCallCounters[actionName, default: 0]
    sayCallCounters[actionName] = callIndex + 1

    // Use action name + call index as the key
    let key = "\(actionName):\(callIndex)"
    let count = interactionCounts[key, default: 0]
    let index = count % variations.count
    let text = variations[index]

    interactionCounts[key] = count + 1

    await say(text)
  }

  func ask(_ string: String, options: [String]) -> String { options[0] }

  func confirm(_ string: String, _ optionA: String, _ optionB: String = "Cancel") -> Bool {
    ask(string, options: [optionA, optionB]) == optionA
  }

  func pause(_ seconds: Float = 1.0) async {
    await Task.sleep(Double(seconds))
  }

  @discardableResult func acquire(_ item: Item, quantity: Int = 1) async -> Bool {
    // Input is already disabled by dialogView.dismiss() when dialog finishes
    // Show PickupView and wait for result
    guard let mainLoop = MainLoop.shared else {
      logger.warning("⚠️ Cannot show PickupView: MainLoop.shared is nil")
      Input.player1.isEnabled = true  // Re-enable on error
      return false
    }

    // Show the pickup view and wait for result
    return await mainLoop.showPickupView(item: item, quantity: quantity)
  }

  func acquire(_ document: Document) {}

  func play(sound soundName: String) {}
  func play(sound soundName: String, at node: Node) {}
  func play(video videoName: String) {}
  func play(cutscene cutsceneName: String) {}

  func fadeOut() {}
  func fadeIn() {}

  /// Shake the screen with the specified intensity
  /// - Parameters:
  ///   - intensity: The intensity of the shake (.subtle or .heavy)
  ///   - axis: Optional axis to limit shake to (.horizontal or .vertical). If nil, shakes on both axes.
  func shakeScreen(_ intensity: ScreenShake.Intensity, axis: Axis? = nil) {
    ScreenShake.shared.shake(intensity, axis: axis)
  }

  func openStorage() {}

  func interact(with node: Node, using item: Item?) {}

  // Default implementations for @SceneScript macro-generated methods
  // These are overridden by the macro in scene script classes
  class func availableMethods() -> [String] {
    return []
  }

  func callMethod(named methodName: String) -> Task<Void, Never>? {
    return nil
  }

}
